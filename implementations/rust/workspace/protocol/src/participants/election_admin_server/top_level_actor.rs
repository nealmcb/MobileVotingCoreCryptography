//! Top-level actor for the Election Administration Server subprotocol
//! implementation.
// Currently ignored for code simplicity until performance data is analyzed.
// @todo Consider boxing structs in large enum variants to improve performance.
#![allow(clippy::large_enum_variant)]

use super::sub_actors::voter_authentication::VoterAuthenticationActor;
use super::sub_actors::voter_authentication::VoterAuthenticationInput;
use super::sub_actors::voter_authentication::VoterAuthenticationOutput;

use crate::crypto::SigningKey;
use crate::elections::ElectionHash;
use crate::messages::AuthReqMsg;
use crate::messages::ProtocolMessage;

use std::collections::HashMap;
use std::time::{Duration, Instant};

/**
* Unique identifier generated by the top-level actor for each newly
* initiated voter authentication request. A 64-bit unsigned integer
* ought be sufficient; otherwise, we may alternatively use [`u128`]
* or a [String].

* All network and Authentication Service (AS) messages are expected
* to be tied to an [`AuthReqId`]. Hence, this identifier is also used
* as a second parameter in subprotocol inputs & outputs to facilitate
* routing of network/AS messages to the correct sub-actor that deals
* with the respective authentication request.
*/
pub type AuthReqId = u64;

// --- I/O Types ---

/**
 * Commands for the top-level voter authentication actor.
 *
 * Note that [`AuthReqMsg`] messages must not be directly forwarded
 * to a sub-actor via a [`SubprotocolInput::VoterAuthentication`]
 * but wrapped into a [`Command::StartVoterAuthentication`] command.
 *
 * This is because the top-level actor has to do some additional work
 * for those messages, i.e., by generating a fresh request id, creating
 * a new [`VoterAuthenticationActor`] sub-actor, etc., before routing
 * them to the newly created sub-actor that handles the authentication
 * request form thereon.
 */
#[derive(Debug, Clone)]
pub enum Command {
    StartVoterAuthentication(AuthReqMsg),
    AbortVoterAuthentication(AuthReqId),
}

// --- Subprotocol Input ---

#[derive(Debug, Clone)]
pub enum SubprotocolInput {
    VoterAuthentication(VoterAuthenticationInput),
}

// --- Actor Input ---

#[derive(Debug, Clone)]
pub enum ActorInput {
    Command(Command),
    SubprotocolInput(SubprotocolInput, AuthReqId),
}

// --- Subprotocol Output ---

#[derive(Debug, Clone)]
pub enum SubprotocolOutput {
    /// Output from a [`VoterAuthenticationActor`] sub-actor.
    VoterAuthentication(VoterAuthenticationOutput, AuthReqId),

    /// The request was manually aborted.
    Aborted(AuthReqId),

    /// The request may have expired.
    RequestNotFound(AuthReqId),
}

// --- Top-Level Actor ---

// Top-level actor for EAS protocol (data)
#[derive(Debug, Clone)]
pub struct TopLevelActor {
    // Shared data between top-level actor and sub-actors.
    election_hash: ElectionHash,
    eas_signing_key: SigningKey,

    // Housekeeping and management of authentication sub-actors.
    requests: HashMap<AuthReqId, VoterAuthenticationActor>,
    next_available_id: AuthReqId,
    network_timeout: Duration, // timeout duration for sub-actors

    // Authentication Service (AS) Credentials
    // This information is also shared with the sub-actors.
    as_project_id: String,
    as_api_key: String,
}

// Top-level actor for EAS protocol (behavior)
impl TopLevelActor {
    /// Creates a new [`TopLevelActor`] instance.
    pub fn new(
        election_hash: ElectionHash,
        eas_signing_key: SigningKey,
        network_timeout: Duration,
        as_project_id: String,
        as_api_key: String,
    ) -> Self {
        Self {
            election_hash,
            eas_signing_key,
            requests: HashMap::new(),
            next_available_id: 0,
            network_timeout,
            as_project_id,
            as_api_key,
        }
    }

    /// Process input to EAS top-level actor.
    pub fn process_input(&mut self, input: ActorInput) -> Result<SubprotocolOutput, String> {
        let result = match input {
            ActorInput::Command(command) => self.handle_command(command),

            ActorInput::SubprotocolInput(subprotocol_input, auth_req_id) => {
                self.handle_subprotocol_input(subprotocol_input, auth_req_id)
            }
        };

        // The state update merely removes subactors that have timed out.
        self.handle_state_update();

        result
    }

    /// Handle command for EAS top-level actor.
    fn handle_command(&mut self, command: Command) -> Result<SubprotocolOutput, String> {
        match command {
            Command::StartVoterAuthentication(auth_req_msg) => {
                // We create a fresh id and sub-actor for each incoming
                // authentication request, even if an authentication
                // request with the same public key is currently being
                // processed or has already been processed.
                let fresh_id: AuthReqId = self.next_available_id;

                match self.next_available_id.checked_add(1) {
                    Some(next) => self.next_available_id = next,
                    None => panic!(
                        "We ran out of 64-bit authentication request ids. This ought be impossible (?)"
                    ),
                }

                // We can assume that we have an unused id here.
                assert!(!self.requests.contains_key(&fresh_id));

                let sub_actor = VoterAuthenticationActor::new(
                    self.election_hash,
                    self.eas_signing_key.clone(),
                    self.as_project_id.clone(),
                    self.as_api_key.clone(),
                );

                self.requests.insert(fresh_id, sub_actor);

                let subactor_input = VoterAuthenticationInput::NetworkMessage(
                    ProtocolMessage::AuthReq(auth_req_msg),
                );

                let output = self
                    .requests
                    .get_mut(&fresh_id)
                    .unwrap() // ought never panic
                    .process_input(subactor_input);

                Ok(SubprotocolOutput::VoterAuthentication(output, fresh_id))
            }

            Command::AbortVoterAuthentication(auth_req_id) => {
                if self.requests.remove(&auth_req_id).is_some() {
                    Ok(SubprotocolOutput::Aborted(auth_req_id))
                } else {
                    Ok(SubprotocolOutput::RequestNotFound(auth_req_id))
                }
            }
        }
    }

    /// Handle and forward subprotocol inputs to sub-actors.
    fn handle_subprotocol_input(
        &mut self,
        subprotocol_input: SubprotocolInput,
        auth_req_id: AuthReqId,
    ) -> Result<SubprotocolOutput, String> {
        match subprotocol_input {
            SubprotocolInput::VoterAuthentication(subactor_input) => {
                match subactor_input {
                    VoterAuthenticationInput::NetworkMessage(ProtocolMessage::AuthReq(_)) => {
                        panic!(
                            "unexpected authentication request message sent directly to sub-actor; issue a StartVoterAuthentication(AuthReqMsg) command instead"
                        )
                    }

                    VoterAuthenticationInput::NetworkMessage(_) => {
                        if self.requests.contains_key(&auth_req_id) {
                            let output = self
                                .requests
                                .get_mut(&auth_req_id)
                                .unwrap() // ought never fail
                                .process_input(subactor_input);

                            Ok(SubprotocolOutput::VoterAuthentication(output, auth_req_id))
                        } else {
                            Ok(SubprotocolOutput::RequestNotFound(auth_req_id))
                        }
                    }

                    VoterAuthenticationInput::AuthServiceMessage(_) => {
                        if self.requests.contains_key(&auth_req_id) {
                            let output = self
                                .requests
                                .get_mut(&auth_req_id)
                                .unwrap() // ought never fail
                                .process_input(subactor_input);

                            Ok(SubprotocolOutput::VoterAuthentication(output, auth_req_id))
                        } else {
                            Ok(SubprotocolOutput::RequestNotFound(auth_req_id))
                        }
                    }

                    VoterAuthenticationInput::BiographicalInfoOk {
                        voter_pseudonym: _,
                        ballot_style: _,
                    } => {
                        if self.requests.contains_key(&auth_req_id) {
                            let output = self
                                .requests
                                .get_mut(&auth_req_id)
                                .unwrap() // ought never fail
                                .process_input(subactor_input);

                            Ok(SubprotocolOutput::VoterAuthentication(output, auth_req_id))
                        } else {
                            Ok(SubprotocolOutput::RequestNotFound(auth_req_id))
                        }
                    }

                    VoterAuthenticationInput::BiographicalInfoInvalid(_) => {
                        if self.requests.contains_key(&auth_req_id) {
                            let output = self
                                .requests
                                .get_mut(&auth_req_id)
                                .unwrap() // ought never fail
                                .process_input(subactor_input);

                            Ok(SubprotocolOutput::VoterAuthentication(output, auth_req_id))
                        } else {
                            Ok(SubprotocolOutput::RequestNotFound(auth_req_id))
                        }
                    }
                }
            }
        }
    }

    /// The state update purges completed and expired requests.
    fn handle_state_update(&mut self) {
        self.purge_completed_requests();
        self.purge_expired_requests();
    }

    /// Purge all sub-actors from [`self.requests`] that have completed.
    fn purge_completed_requests(&mut self) {
        self.requests.retain(|_, request| !request.has_completed());
    }

    /// Purge all sub-actors from [`self.requests`] that have timed out.
    fn purge_expired_requests(&mut self) {
        let now = Instant::now();
        self.requests
            .retain(|_, request| now - request.get_time_of_last_input() <= self.network_timeout);
    }
}
